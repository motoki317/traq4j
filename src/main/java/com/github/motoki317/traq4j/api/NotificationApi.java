/*
 * traQ v3
 * traQ v3 API
 *
 * The version of the OpenAPI document: 3.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.github.motoki317.traq4j.api;

import com.github.motoki317.traq4j.ApiCallback;
import com.github.motoki317.traq4j.ApiClient;
import com.github.motoki317.traq4j.ApiException;
import com.github.motoki317.traq4j.ApiResponse;
import com.github.motoki317.traq4j.Configuration;
import com.github.motoki317.traq4j.Pair;
import com.github.motoki317.traq4j.ProgressRequestBody;
import com.github.motoki317.traq4j.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.github.motoki317.traq4j.model.MyChannelViewState;
import com.github.motoki317.traq4j.model.PatchChannelSubscribersRequest;
import com.github.motoki317.traq4j.model.PostMyFCMDeviceRequest;
import com.github.motoki317.traq4j.model.PutChannelSubscribeLevelRequest;
import com.github.motoki317.traq4j.model.PutChannelSubscribersRequest;
import java.util.UUID;
import com.github.motoki317.traq4j.model.UnreadChannel;
import com.github.motoki317.traq4j.model.UserSubscribeState;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class NotificationApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public NotificationApi() {
        this(Configuration.getDefaultApiClient());
    }

    public NotificationApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for editChannelSubscribers
     * @param channelId チャンネルUUID (required)
     * @param patchChannelSubscribersRequest  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content 変更できました。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden 指定したチャンネルの通知購読者は変更できません。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found チャンネルが見つかりません。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call editChannelSubscribersCall(UUID channelId, PatchChannelSubscribersRequest patchChannelSubscribersRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = patchChannelSubscribersRequest;

        // create path and map variables
        String localVarPath = "/channels/{channelId}/subscribers"
            .replaceAll("\\{" + "channelId" + "\\}", localVarApiClient.escapeString(channelId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "bearerAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call editChannelSubscribersValidateBeforeCall(UUID channelId, PatchChannelSubscribersRequest patchChannelSubscribersRequest, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'channelId' is set
        if (channelId == null) {
            throw new ApiException("Missing the required parameter 'channelId' when calling editChannelSubscribers(Async)");
        }
        

        okhttp3.Call localVarCall = editChannelSubscribersCall(channelId, patchChannelSubscribersRequest, _callback);
        return localVarCall;

    }

    /**
     * チャンネルの通知購読者を編集
     * 指定したチャンネルの通知購読者を編集します。 リクエストに含めなかったユーザーの通知購読状態は変更しません。 また、存在しないユーザーを指定した場合は無視されます。
     * @param channelId チャンネルUUID (required)
     * @param patchChannelSubscribersRequest  (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content 変更できました。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden 指定したチャンネルの通知購読者は変更できません。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found チャンネルが見つかりません。 </td><td>  -  </td></tr>
     </table>
     */
    public void editChannelSubscribers(UUID channelId, PatchChannelSubscribersRequest patchChannelSubscribersRequest) throws ApiException {
        editChannelSubscribersWithHttpInfo(channelId, patchChannelSubscribersRequest);
    }

    /**
     * チャンネルの通知購読者を編集
     * 指定したチャンネルの通知購読者を編集します。 リクエストに含めなかったユーザーの通知購読状態は変更しません。 また、存在しないユーザーを指定した場合は無視されます。
     * @param channelId チャンネルUUID (required)
     * @param patchChannelSubscribersRequest  (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content 変更できました。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden 指定したチャンネルの通知購読者は変更できません。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found チャンネルが見つかりません。 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> editChannelSubscribersWithHttpInfo(UUID channelId, PatchChannelSubscribersRequest patchChannelSubscribersRequest) throws ApiException {
        okhttp3.Call localVarCall = editChannelSubscribersValidateBeforeCall(channelId, patchChannelSubscribersRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * チャンネルの通知購読者を編集 (asynchronously)
     * 指定したチャンネルの通知購読者を編集します。 リクエストに含めなかったユーザーの通知購読状態は変更しません。 また、存在しないユーザーを指定した場合は無視されます。
     * @param channelId チャンネルUUID (required)
     * @param patchChannelSubscribersRequest  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content 変更できました。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden 指定したチャンネルの通知購読者は変更できません。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found チャンネルが見つかりません。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call editChannelSubscribersAsync(UUID channelId, PatchChannelSubscribersRequest patchChannelSubscribersRequest, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = editChannelSubscribersValidateBeforeCall(channelId, patchChannelSubscribersRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for getChannelSubscribers
     * @param channelId チャンネルUUID (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden プライベートチャンネル・強制通知チャンネルの設定は取得できません。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found チャンネルが見つかりません。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getChannelSubscribersCall(UUID channelId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/channels/{channelId}/subscribers"
            .replaceAll("\\{" + "channelId" + "\\}", localVarApiClient.escapeString(channelId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "bearerAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getChannelSubscribersValidateBeforeCall(UUID channelId, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'channelId' is set
        if (channelId == null) {
            throw new ApiException("Missing the required parameter 'channelId' when calling getChannelSubscribers(Async)");
        }
        

        okhttp3.Call localVarCall = getChannelSubscribersCall(channelId, _callback);
        return localVarCall;

    }

    /**
     * チャンネルの通知購読者のリストを取得
     * 指定したチャンネルを通知購読しているユーザーのUUIDのリストを取得します。
     * @param channelId チャンネルUUID (required)
     * @return List&lt;UUID&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden プライベートチャンネル・強制通知チャンネルの設定は取得できません。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found チャンネルが見つかりません。 </td><td>  -  </td></tr>
     </table>
     */
    public List<UUID> getChannelSubscribers(UUID channelId) throws ApiException {
        ApiResponse<List<UUID>> localVarResp = getChannelSubscribersWithHttpInfo(channelId);
        return localVarResp.getData();
    }

    /**
     * チャンネルの通知購読者のリストを取得
     * 指定したチャンネルを通知購読しているユーザーのUUIDのリストを取得します。
     * @param channelId チャンネルUUID (required)
     * @return ApiResponse&lt;List&lt;UUID&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden プライベートチャンネル・強制通知チャンネルの設定は取得できません。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found チャンネルが見つかりません。 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<UUID>> getChannelSubscribersWithHttpInfo(UUID channelId) throws ApiException {
        okhttp3.Call localVarCall = getChannelSubscribersValidateBeforeCall(channelId, null);
        Type localVarReturnType = new TypeToken<List<UUID>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * チャンネルの通知購読者のリストを取得 (asynchronously)
     * 指定したチャンネルを通知購読しているユーザーのUUIDのリストを取得します。
     * @param channelId チャンネルUUID (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden プライベートチャンネル・強制通知チャンネルの設定は取得できません。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found チャンネルが見つかりません。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getChannelSubscribersAsync(UUID channelId, final ApiCallback<List<UUID>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getChannelSubscribersValidateBeforeCall(channelId, _callback);
        Type localVarReturnType = new TypeToken<List<UUID>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getMyChannelSubscriptions
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMyChannelSubscriptionsCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/me/subscriptions";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "bearerAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getMyChannelSubscriptionsValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        

        okhttp3.Call localVarCall = getMyChannelSubscriptionsCall(_callback);
        return localVarCall;

    }

    /**
     * 自分のチャンネル購読状態を取得
     * 自身のチャンネル購読状態を取得します。
     * @return List&lt;UserSubscribeState&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<UserSubscribeState> getMyChannelSubscriptions() throws ApiException {
        ApiResponse<List<UserSubscribeState>> localVarResp = getMyChannelSubscriptionsWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * 自分のチャンネル購読状態を取得
     * 自身のチャンネル購読状態を取得します。
     * @return ApiResponse&lt;List&lt;UserSubscribeState&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<UserSubscribeState>> getMyChannelSubscriptionsWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = getMyChannelSubscriptionsValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<List<UserSubscribeState>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 自分のチャンネル購読状態を取得 (asynchronously)
     * 自身のチャンネル購読状態を取得します。
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMyChannelSubscriptionsAsync(final ApiCallback<List<UserSubscribeState>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getMyChannelSubscriptionsValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<List<UserSubscribeState>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getMyUnreadChannels
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMyUnreadChannelsCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/me/unread";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "bearerAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getMyUnreadChannelsValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        

        okhttp3.Call localVarCall = getMyUnreadChannelsCall(_callback);
        return localVarCall;

    }

    /**
     * 未読チャンネルを取得
     * 自分が現在未読のチャンネルの未読情報を取得します。
     * @return List&lt;UnreadChannel&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<UnreadChannel> getMyUnreadChannels() throws ApiException {
        ApiResponse<List<UnreadChannel>> localVarResp = getMyUnreadChannelsWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * 未読チャンネルを取得
     * 自分が現在未読のチャンネルの未読情報を取得します。
     * @return ApiResponse&lt;List&lt;UnreadChannel&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<UnreadChannel>> getMyUnreadChannelsWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = getMyUnreadChannelsValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<List<UnreadChannel>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 未読チャンネルを取得 (asynchronously)
     * 自分が現在未読のチャンネルの未読情報を取得します。
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMyUnreadChannelsAsync(final ApiCallback<List<UnreadChannel>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getMyUnreadChannelsValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<List<UnreadChannel>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getMyViewStates
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMyViewStatesCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/me/view-states";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "bearerAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getMyViewStatesValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        

        okhttp3.Call localVarCall = getMyViewStatesCall(_callback);
        return localVarCall;

    }

    /**
     * 自身のチャンネル閲覧状態一覧を取得
     * 自身のチャンネル閲覧状態一覧を取得します。
     * @return List&lt;MyChannelViewState&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<MyChannelViewState> getMyViewStates() throws ApiException {
        ApiResponse<List<MyChannelViewState>> localVarResp = getMyViewStatesWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * 自身のチャンネル閲覧状態一覧を取得
     * 自身のチャンネル閲覧状態一覧を取得します。
     * @return ApiResponse&lt;List&lt;MyChannelViewState&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<MyChannelViewState>> getMyViewStatesWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = getMyViewStatesValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<List<MyChannelViewState>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * 自身のチャンネル閲覧状態一覧を取得 (asynchronously)
     * 自身のチャンネル閲覧状態一覧を取得します。
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMyViewStatesAsync(final ApiCallback<List<MyChannelViewState>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getMyViewStatesValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<List<MyChannelViewState>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for readChannel
     * @param channelId チャンネルUUID (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content 既読にしました。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call readChannelCall(UUID channelId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/me/unread/{channelId}"
            .replaceAll("\\{" + "channelId" + "\\}", localVarApiClient.escapeString(channelId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "bearerAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call readChannelValidateBeforeCall(UUID channelId, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'channelId' is set
        if (channelId == null) {
            throw new ApiException("Missing the required parameter 'channelId' when calling readChannel(Async)");
        }
        

        okhttp3.Call localVarCall = readChannelCall(channelId, _callback);
        return localVarCall;

    }

    /**
     * チャンネルを既読にする
     * 自分が未読のチャンネルを既読にします。
     * @param channelId チャンネルUUID (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content 既読にしました。 </td><td>  -  </td></tr>
     </table>
     */
    public void readChannel(UUID channelId) throws ApiException {
        readChannelWithHttpInfo(channelId);
    }

    /**
     * チャンネルを既読にする
     * 自分が未読のチャンネルを既読にします。
     * @param channelId チャンネルUUID (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content 既読にしました。 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> readChannelWithHttpInfo(UUID channelId) throws ApiException {
        okhttp3.Call localVarCall = readChannelValidateBeforeCall(channelId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * チャンネルを既読にする (asynchronously)
     * 自分が未読のチャンネルを既読にします。
     * @param channelId チャンネルUUID (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content 既読にしました。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call readChannelAsync(UUID channelId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = readChannelValidateBeforeCall(channelId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for registerFCMDevice
     * @param postMyFCMDeviceRequest  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content 登録できました。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call registerFCMDeviceCall(PostMyFCMDeviceRequest postMyFCMDeviceRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = postMyFCMDeviceRequest;

        // create path and map variables
        String localVarPath = "/users/me/fcm-device";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "bearerAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call registerFCMDeviceValidateBeforeCall(PostMyFCMDeviceRequest postMyFCMDeviceRequest, final ApiCallback _callback) throws ApiException {
        

        okhttp3.Call localVarCall = registerFCMDeviceCall(postMyFCMDeviceRequest, _callback);
        return localVarCall;

    }

    /**
     * FCMデバイスを登録
     * 自身のFCMデバイスを登録します。
     * @param postMyFCMDeviceRequest  (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content 登録できました。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public void registerFCMDevice(PostMyFCMDeviceRequest postMyFCMDeviceRequest) throws ApiException {
        registerFCMDeviceWithHttpInfo(postMyFCMDeviceRequest);
    }

    /**
     * FCMデバイスを登録
     * 自身のFCMデバイスを登録します。
     * @param postMyFCMDeviceRequest  (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content 登録できました。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> registerFCMDeviceWithHttpInfo(PostMyFCMDeviceRequest postMyFCMDeviceRequest) throws ApiException {
        okhttp3.Call localVarCall = registerFCMDeviceValidateBeforeCall(postMyFCMDeviceRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * FCMデバイスを登録 (asynchronously)
     * 自身のFCMデバイスを登録します。
     * @param postMyFCMDeviceRequest  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content 登録できました。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call registerFCMDeviceAsync(PostMyFCMDeviceRequest postMyFCMDeviceRequest, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = registerFCMDeviceValidateBeforeCall(postMyFCMDeviceRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for setChannelSubscribeLevel
     * @param channelId チャンネルUUID (required)
     * @param putChannelSubscribeLevelRequest  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content 変更されました。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden 指定したチャンネルの通知購読レベルは変更できません。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found チャンネルが見つかりません。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call setChannelSubscribeLevelCall(UUID channelId, PutChannelSubscribeLevelRequest putChannelSubscribeLevelRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = putChannelSubscribeLevelRequest;

        // create path and map variables
        String localVarPath = "/users/me/subscriptions/{channelId}"
            .replaceAll("\\{" + "channelId" + "\\}", localVarApiClient.escapeString(channelId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "bearerAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call setChannelSubscribeLevelValidateBeforeCall(UUID channelId, PutChannelSubscribeLevelRequest putChannelSubscribeLevelRequest, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'channelId' is set
        if (channelId == null) {
            throw new ApiException("Missing the required parameter 'channelId' when calling setChannelSubscribeLevel(Async)");
        }
        

        okhttp3.Call localVarCall = setChannelSubscribeLevelCall(channelId, putChannelSubscribeLevelRequest, _callback);
        return localVarCall;

    }

    /**
     * チャンネル購読レベルを設定
     * 自身の指定したチャンネルの購読レベルを設定します。
     * @param channelId チャンネルUUID (required)
     * @param putChannelSubscribeLevelRequest  (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content 変更されました。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden 指定したチャンネルの通知購読レベルは変更できません。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found チャンネルが見つかりません。 </td><td>  -  </td></tr>
     </table>
     */
    public void setChannelSubscribeLevel(UUID channelId, PutChannelSubscribeLevelRequest putChannelSubscribeLevelRequest) throws ApiException {
        setChannelSubscribeLevelWithHttpInfo(channelId, putChannelSubscribeLevelRequest);
    }

    /**
     * チャンネル購読レベルを設定
     * 自身の指定したチャンネルの購読レベルを設定します。
     * @param channelId チャンネルUUID (required)
     * @param putChannelSubscribeLevelRequest  (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content 変更されました。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden 指定したチャンネルの通知購読レベルは変更できません。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found チャンネルが見つかりません。 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> setChannelSubscribeLevelWithHttpInfo(UUID channelId, PutChannelSubscribeLevelRequest putChannelSubscribeLevelRequest) throws ApiException {
        okhttp3.Call localVarCall = setChannelSubscribeLevelValidateBeforeCall(channelId, putChannelSubscribeLevelRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * チャンネル購読レベルを設定 (asynchronously)
     * 自身の指定したチャンネルの購読レベルを設定します。
     * @param channelId チャンネルUUID (required)
     * @param putChannelSubscribeLevelRequest  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content 変更されました。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden 指定したチャンネルの通知購読レベルは変更できません。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found チャンネルが見つかりません。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call setChannelSubscribeLevelAsync(UUID channelId, PutChannelSubscribeLevelRequest putChannelSubscribeLevelRequest, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = setChannelSubscribeLevelValidateBeforeCall(channelId, putChannelSubscribeLevelRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for setChannelSubscribers
     * @param channelId チャンネルUUID (required)
     * @param putChannelSubscribersRequest  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content 変更されました。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden 指定したチャンネルの通知購読者は変更できません。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found チャンネルが見つかりません。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call setChannelSubscribersCall(UUID channelId, PutChannelSubscribersRequest putChannelSubscribersRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = putChannelSubscribersRequest;

        // create path and map variables
        String localVarPath = "/channels/{channelId}/subscribers"
            .replaceAll("\\{" + "channelId" + "\\}", localVarApiClient.escapeString(channelId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "bearerAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call setChannelSubscribersValidateBeforeCall(UUID channelId, PutChannelSubscribersRequest putChannelSubscribersRequest, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'channelId' is set
        if (channelId == null) {
            throw new ApiException("Missing the required parameter 'channelId' when calling setChannelSubscribers(Async)");
        }
        

        okhttp3.Call localVarCall = setChannelSubscribersCall(channelId, putChannelSubscribersRequest, _callback);
        return localVarCall;

    }

    /**
     * チャンネルの通知購読者を設定
     * 指定したチャンネルの通知購読者を設定します。 リクエストに含めなかったユーザーの通知購読状態はオフになります。 また、存在しないユーザーを指定した場合は無視されます。
     * @param channelId チャンネルUUID (required)
     * @param putChannelSubscribersRequest  (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content 変更されました。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden 指定したチャンネルの通知購読者は変更できません。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found チャンネルが見つかりません。 </td><td>  -  </td></tr>
     </table>
     */
    public void setChannelSubscribers(UUID channelId, PutChannelSubscribersRequest putChannelSubscribersRequest) throws ApiException {
        setChannelSubscribersWithHttpInfo(channelId, putChannelSubscribersRequest);
    }

    /**
     * チャンネルの通知購読者を設定
     * 指定したチャンネルの通知購読者を設定します。 リクエストに含めなかったユーザーの通知購読状態はオフになります。 また、存在しないユーザーを指定した場合は無視されます。
     * @param channelId チャンネルUUID (required)
     * @param putChannelSubscribersRequest  (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content 変更されました。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden 指定したチャンネルの通知購読者は変更できません。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found チャンネルが見つかりません。 </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> setChannelSubscribersWithHttpInfo(UUID channelId, PutChannelSubscribersRequest putChannelSubscribersRequest) throws ApiException {
        okhttp3.Call localVarCall = setChannelSubscribersValidateBeforeCall(channelId, putChannelSubscribersRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * チャンネルの通知購読者を設定 (asynchronously)
     * 指定したチャンネルの通知購読者を設定します。 リクエストに含めなかったユーザーの通知購読状態はオフになります。 また、存在しないユーザーを指定した場合は無視されます。
     * @param channelId チャンネルUUID (required)
     * @param putChannelSubscribersRequest  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content 変更されました。 </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden 指定したチャンネルの通知購読者は変更できません。 </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found チャンネルが見つかりません。 </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call setChannelSubscribersAsync(UUID channelId, PutChannelSubscribersRequest putChannelSubscribersRequest, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = setChannelSubscribersValidateBeforeCall(channelId, putChannelSubscribersRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for ws
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 101 </td><td> Switching Protocols </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call wsCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/ws";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "bearerAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call wsValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        

        okhttp3.Call localVarCall = wsCall(_callback);
        return localVarCall;

    }

    /**
     * WebSocket通知ストリームに接続します
     * # WebSocketプロトコル ## 送信 &#x60;コマンド:引数1:引数2:...&#x60;のような形式のTextMessageをサーバーに送信することで、このWebSocketセッションに対する設定が実行できる。 ### &#x60;viewstate&#x60;コマンド このWebSocketセッションが見ているチャンネル(イベントを受け取るチャンネル)を設定する。 現時点では1つのセッションに対して1つのチャンネルしか設定できない。  &#x60;viewstate:{チャンネルID}:{閲覧状態}&#x60; + チャンネルID: 対象のチャンネルID + 閲覧状態: &#x60;none&#x60;, &#x60;monitoring&#x60;, &#x60;editing&#x60;  最初の&#x60;viewstate&#x60;コマンドを送る前、または&#x60;viewstate:null&#x60;, &#x60;viewstate:&#x60;を送信した後は、このセッションはどこのチャンネルも見ていないことになる。  ### &#x60;rtcstate&#x60;コマンド 自分のWebRTC状態を変更する。 他のコネクションが既に状態を保持している場合、変更することができません。  &#x60;rtcstate:{チャンネルID}:({状態}:{セッションID})*&#x60;  コネクションが切断された場合、自分のWebRTC状態はリセットされます。  ### &#x60;timeline_streaming&#x60;コマンド 全てのパブリックチャンネルの&#x60;MESSAGE_CREATED&#x60;イベントを受け取るかどうかを設定する。 初期状態は&#x60;off&#x60;です。  &#x60;timeline_streaming:(on|off|true|false)&#x60;  ## 受信 TextMessageとして各種イベントが&#x60;type&#x60;と&#x60;body&#x60;を持つJSONとして非同期に送られます。  例: &#x60;&#x60;&#x60;json {\&quot;type\&quot;:\&quot;USER_ONLINE\&quot;,\&quot;body\&quot;:{\&quot;id\&quot;:\&quot;7dd8e07f-7f5d-4331-9176-b56a4299768b\&quot;}} &#x60;&#x60;&#x60;  ## イベント一覧  ### &#x60;USER_JOINED&#x60; ユーザーが新規登録された。  対象: 全員  + &#x60;id&#x60;: 登録されたユーザーのId  ### &#x60;USER_UPDATED&#x60; ユーザーの情報が更新された。  対象: 全員  + &#x60;id&#x60;: 情報が更新されたユーザーのId  ### &#x60;USER_TAGS_UPDATED&#x60; ユーザーのタグが更新された。  対象: 全員  + &#x60;id&#x60;: タグが更新されたユーザーのId + &#x60;tag_id&#x60;: 更新されたタグのId  ### &#x60;USER_ICON_UPDATED&#x60; ユーザーのアイコンが更新された。  対象: 全員  + &#x60;id&#x60;: アイコンが更新されたユーザーのId  ### &#x60;USER_WEBRTC_STATE_CHANGED&#x60; ユーザーのWebRTCの状態が変化した  対象: 全員  + &#x60;user_id&#x60;: 変更があったユーザーのId + &#x60;channel_id&#x60;: ユーザーの変更後の接続チャンネルのId + &#x60;sessions&#x60;: ユーザーの変更後の状態(配列)   + &#x60;state&#x60;: 状態   + &#x60;sessionId&#x60;: セッションID  ### &#x60;USER_VIEWSTATE_CHANGED&#x60; ユーザーのチャンネルの閲覧状態が変化した  対象: 変化したWSセッションを含めた、該当ユーザーのWSセッション全て  + &#x60;view_states&#x60;: 変化したWSセッションを含めた、該当ユーザーの変更後の状態(配列)   + &#x60;key&#x60;: WSセッションの識別子   + &#x60;channel_id&#x60;: 閲覧しているチャンネルId   + &#x60;state&#x60;: 閲覧状態  ### &#x60;USER_ONLINE&#x60; ユーザーがオンラインになった。  対象: 全員  + &#x60;id&#x60;: オンラインになったユーザーのId  ### &#x60;USER_OFFLINE&#x60; ユーザーがオフラインになった。  対象: 全員  + &#x60;id&#x60;: オフラインになったユーザーのId  ### &#x60;USER_GROUP_CREATED&#x60; ユーザーグループが作成された  対象: 全員  + &#x60;id&#x60;: 作成されたユーザーグループのId  ### &#x60;USER_GROUP_UPDATED&#x60; ユーザーグループが更新された  対象: 全員  + &#x60;id&#x60;: 作成されたユーザーグループのId  ### &#x60;USER_GROUP_DELETED&#x60; ユーザーグループが削除された  対象: 全員  + &#x60;id&#x60;: 削除されたユーザーグループのId  ### &#x60;CHANNEL_CREATED&#x60; チャンネルが新規作成された。  対象: 該当チャンネルを閲覧可能な全員  + &#x60;id&#x60;: 作成されたチャンネルのId + &#x60;dm_user_id&#x60;: (DMの場合のみ) DM相手のユーザーId  ### &#x60;CHANNEL_UPDATED&#x60; チャンネルの情報が変更された。  対象: 該当チャンネルを閲覧可能な全員  + &#x60;id&#x60;: 変更があったチャンネルのId + &#x60;dm_user_id&#x60;: (DMの場合のみ) DM相手のユーザーId  ### &#x60;CHANNEL_DELETED&#x60; チャンネルが削除された。  対象: 該当チャンネルを閲覧可能な全員  + &#x60;id&#x60;: 削除されたチャンネルのId + &#x60;dm_user_id&#x60;: (DMの場合のみ) DM相手のユーザーId  ### &#x60;CHANNEL_STARED&#x60; 自分がチャンネルをスターした。  対象: 自分  + &#x60;id&#x60;: スターしたチャンネルのId  ### &#x60;CHANNEL_UNSTARED&#x60; 自分がチャンネルのスターを解除した。  対象: 自分  + &#x60;id&#x60;: スターしたチャンネルのId  ### &#x60;CHANNEL_VIEWERS_CHANGED&#x60; チャンネルの閲覧者が変化した。  対象: 該当チャンネルを閲覧しているユーザー  + &#x60;id&#x60;: 変化したチャンネルのId + &#x60;viewers&#x60;: 変化後の閲覧者(配列)   + &#x60;userId&#x60;: ユーザーId   + &#x60;state&#x60;: 閲覧状態   + &#x60;updatedAt&#x60;: 閲覧状態の更新日時  ### &#x60;CHANNEL_SUBSCRIBERS_CHANGED&#x60; チャンネルの購読者が変化した。  対象: 該当チャンネルを閲覧しているユーザー  + &#x60;id&#x60;: 変化したチャンネルのId  ### &#x60;MESSAGE_CREATED&#x60; メッセージが投稿された。  対象: 投稿チャンネルを閲覧しているユーザー・投稿チャンネルに通知をつけているユーザー・メンションを受けたユーザー  + &#x60;id&#x60;: 投稿されたメッセージのId + &#x60;is_citing&#x60;: 投稿されたメッセージがWebSocketを接続しているユーザーの投稿を引用しているかどうか  ### &#x60;MESSAGE_UPDATED&#x60; メッセージが更新された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;id&#x60;: 更新されたメッセージのId  ### &#x60;MESSAGE_DELETED&#x60; メッセージが削除された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;id&#x60;: 削除されたメッセージのId  ### &#x60;MESSAGE_STAMPED&#x60; メッセージにスタンプが押された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;message_id&#x60;: メッセージId + &#x60;user_id&#x60;: スタンプを押したユーザーのId + &#x60;stamp_id&#x60;: スタンプのId + &#x60;count&#x60;: そのユーザーが押した数 + &#x60;created_at&#x60;: そのユーザーがそのスタンプをそのメッセージに最初に押した日時  ### &#x60;MESSAGE_UNSTAMPED&#x60; メッセージからスタンプが外された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;message_id&#x60;: メッセージId + &#x60;user_id&#x60;: スタンプを押したユーザーのId + &#x60;stamp_id&#x60;: スタンプのId  ### &#x60;MESSAGE_PINNED&#x60; メッセージがピン留めされた。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;message_id&#x60;: ピンされたメッセージのID + &#x60;channel_id&#x60;: ピンされたメッセージのチャンネルID  ### &#x60;MESSAGE_UNPINNED&#x60; ピン留めされたメッセージのピンが外された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;message_id&#x60;: ピンが外されたメッセージのID + &#x60;channel_id&#x60;: ピンが外されたメッセージのチャンネルID  ### &#x60;MESSAGE_READ&#x60; 自分があるチャンネルのメッセージを読んだ。  対象: 自分  + &#x60;id&#x60;: 読んだチャンネルId  ### &#x60;STAMP_CREATED&#x60; スタンプが新しく追加された。  対象: 全員  + &#x60;id&#x60;: 作成されたスタンプのId  ### &#x60;STAMP_UPDATED&#x60; スタンプが修正された。  対象: 全員  + &#x60;id&#x60;: 修正されたスタンプのId  ### &#x60;STAMP_DELETED&#x60; スタンプが削除された。  対象: 全員  + &#x60;id&#x60;: 削除されたスタンプのId  ### &#x60;STAMP_PALETTE_CREATED&#x60; スタンプパレットが新しく追加された。  対象: 自分  + &#x60;id&#x60;: 作成されたスタンプパレットのId  ### &#x60;STAMP_PALETTE_UPDATED&#x60; スタンプパレットが修正された。  対象: 自分  + &#x60;id&#x60;: 修正されたスタンプパレットのId  ### &#x60;STAMP_PALETTE_DELETED&#x60; スタンプパレットが削除された。  対象: 自分  + &#x60;id&#x60;: 削除されたスタンプパレットのId  ### &#x60;CLIP_FOLDER_CREATED&#x60; クリップフォルダーが作成された。  対象：自分  + &#x60;id&#x60;: 作成されたクリップフォルダーのId  ### &#x60;CLIP_FOLDER_UPDATED&#x60; クリップフォルダーが修正された。  対象: 自分  + &#x60;id&#x60;: 更新されたクリップフォルダーのId  ### &#x60;CLIP_FOLDER_DELETED&#x60; クリップフォルダーが削除された。  対象: 自分  + &#x60;id&#x60;: 削除されたクリップフォルダーのId  ### &#x60;CLIP_FOLDER_MESSAGE_DELETED&#x60; クリップフォルダーからメッセージが除外された。  対象: 自分  + &#x60;folder_id&#x60;: メッセージが除外されたクリップフォルダーのId + &#x60;message_id&#x60;: クリップフォルダーから除外されたメッセージのId  ### &#x60;CLIP_FOLDER_MESSAGE_ADDED&#x60; クリップフォルダーにメッセージが追加された。  対象: 自分  + &#x60;folder_id&#x60;: メッセージが追加されたクリップフォルダーのId + &#x60;message_id&#x60;: クリップフォルダーに追加されたメッセージのId
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 101 </td><td> Switching Protocols </td><td>  -  </td></tr>
     </table>
     */
    public void ws() throws ApiException {
        wsWithHttpInfo();
    }

    /**
     * WebSocket通知ストリームに接続します
     * # WebSocketプロトコル ## 送信 &#x60;コマンド:引数1:引数2:...&#x60;のような形式のTextMessageをサーバーに送信することで、このWebSocketセッションに対する設定が実行できる。 ### &#x60;viewstate&#x60;コマンド このWebSocketセッションが見ているチャンネル(イベントを受け取るチャンネル)を設定する。 現時点では1つのセッションに対して1つのチャンネルしか設定できない。  &#x60;viewstate:{チャンネルID}:{閲覧状態}&#x60; + チャンネルID: 対象のチャンネルID + 閲覧状態: &#x60;none&#x60;, &#x60;monitoring&#x60;, &#x60;editing&#x60;  最初の&#x60;viewstate&#x60;コマンドを送る前、または&#x60;viewstate:null&#x60;, &#x60;viewstate:&#x60;を送信した後は、このセッションはどこのチャンネルも見ていないことになる。  ### &#x60;rtcstate&#x60;コマンド 自分のWebRTC状態を変更する。 他のコネクションが既に状態を保持している場合、変更することができません。  &#x60;rtcstate:{チャンネルID}:({状態}:{セッションID})*&#x60;  コネクションが切断された場合、自分のWebRTC状態はリセットされます。  ### &#x60;timeline_streaming&#x60;コマンド 全てのパブリックチャンネルの&#x60;MESSAGE_CREATED&#x60;イベントを受け取るかどうかを設定する。 初期状態は&#x60;off&#x60;です。  &#x60;timeline_streaming:(on|off|true|false)&#x60;  ## 受信 TextMessageとして各種イベントが&#x60;type&#x60;と&#x60;body&#x60;を持つJSONとして非同期に送られます。  例: &#x60;&#x60;&#x60;json {\&quot;type\&quot;:\&quot;USER_ONLINE\&quot;,\&quot;body\&quot;:{\&quot;id\&quot;:\&quot;7dd8e07f-7f5d-4331-9176-b56a4299768b\&quot;}} &#x60;&#x60;&#x60;  ## イベント一覧  ### &#x60;USER_JOINED&#x60; ユーザーが新規登録された。  対象: 全員  + &#x60;id&#x60;: 登録されたユーザーのId  ### &#x60;USER_UPDATED&#x60; ユーザーの情報が更新された。  対象: 全員  + &#x60;id&#x60;: 情報が更新されたユーザーのId  ### &#x60;USER_TAGS_UPDATED&#x60; ユーザーのタグが更新された。  対象: 全員  + &#x60;id&#x60;: タグが更新されたユーザーのId + &#x60;tag_id&#x60;: 更新されたタグのId  ### &#x60;USER_ICON_UPDATED&#x60; ユーザーのアイコンが更新された。  対象: 全員  + &#x60;id&#x60;: アイコンが更新されたユーザーのId  ### &#x60;USER_WEBRTC_STATE_CHANGED&#x60; ユーザーのWebRTCの状態が変化した  対象: 全員  + &#x60;user_id&#x60;: 変更があったユーザーのId + &#x60;channel_id&#x60;: ユーザーの変更後の接続チャンネルのId + &#x60;sessions&#x60;: ユーザーの変更後の状態(配列)   + &#x60;state&#x60;: 状態   + &#x60;sessionId&#x60;: セッションID  ### &#x60;USER_VIEWSTATE_CHANGED&#x60; ユーザーのチャンネルの閲覧状態が変化した  対象: 変化したWSセッションを含めた、該当ユーザーのWSセッション全て  + &#x60;view_states&#x60;: 変化したWSセッションを含めた、該当ユーザーの変更後の状態(配列)   + &#x60;key&#x60;: WSセッションの識別子   + &#x60;channel_id&#x60;: 閲覧しているチャンネルId   + &#x60;state&#x60;: 閲覧状態  ### &#x60;USER_ONLINE&#x60; ユーザーがオンラインになった。  対象: 全員  + &#x60;id&#x60;: オンラインになったユーザーのId  ### &#x60;USER_OFFLINE&#x60; ユーザーがオフラインになった。  対象: 全員  + &#x60;id&#x60;: オフラインになったユーザーのId  ### &#x60;USER_GROUP_CREATED&#x60; ユーザーグループが作成された  対象: 全員  + &#x60;id&#x60;: 作成されたユーザーグループのId  ### &#x60;USER_GROUP_UPDATED&#x60; ユーザーグループが更新された  対象: 全員  + &#x60;id&#x60;: 作成されたユーザーグループのId  ### &#x60;USER_GROUP_DELETED&#x60; ユーザーグループが削除された  対象: 全員  + &#x60;id&#x60;: 削除されたユーザーグループのId  ### &#x60;CHANNEL_CREATED&#x60; チャンネルが新規作成された。  対象: 該当チャンネルを閲覧可能な全員  + &#x60;id&#x60;: 作成されたチャンネルのId + &#x60;dm_user_id&#x60;: (DMの場合のみ) DM相手のユーザーId  ### &#x60;CHANNEL_UPDATED&#x60; チャンネルの情報が変更された。  対象: 該当チャンネルを閲覧可能な全員  + &#x60;id&#x60;: 変更があったチャンネルのId + &#x60;dm_user_id&#x60;: (DMの場合のみ) DM相手のユーザーId  ### &#x60;CHANNEL_DELETED&#x60; チャンネルが削除された。  対象: 該当チャンネルを閲覧可能な全員  + &#x60;id&#x60;: 削除されたチャンネルのId + &#x60;dm_user_id&#x60;: (DMの場合のみ) DM相手のユーザーId  ### &#x60;CHANNEL_STARED&#x60; 自分がチャンネルをスターした。  対象: 自分  + &#x60;id&#x60;: スターしたチャンネルのId  ### &#x60;CHANNEL_UNSTARED&#x60; 自分がチャンネルのスターを解除した。  対象: 自分  + &#x60;id&#x60;: スターしたチャンネルのId  ### &#x60;CHANNEL_VIEWERS_CHANGED&#x60; チャンネルの閲覧者が変化した。  対象: 該当チャンネルを閲覧しているユーザー  + &#x60;id&#x60;: 変化したチャンネルのId + &#x60;viewers&#x60;: 変化後の閲覧者(配列)   + &#x60;userId&#x60;: ユーザーId   + &#x60;state&#x60;: 閲覧状態   + &#x60;updatedAt&#x60;: 閲覧状態の更新日時  ### &#x60;CHANNEL_SUBSCRIBERS_CHANGED&#x60; チャンネルの購読者が変化した。  対象: 該当チャンネルを閲覧しているユーザー  + &#x60;id&#x60;: 変化したチャンネルのId  ### &#x60;MESSAGE_CREATED&#x60; メッセージが投稿された。  対象: 投稿チャンネルを閲覧しているユーザー・投稿チャンネルに通知をつけているユーザー・メンションを受けたユーザー  + &#x60;id&#x60;: 投稿されたメッセージのId + &#x60;is_citing&#x60;: 投稿されたメッセージがWebSocketを接続しているユーザーの投稿を引用しているかどうか  ### &#x60;MESSAGE_UPDATED&#x60; メッセージが更新された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;id&#x60;: 更新されたメッセージのId  ### &#x60;MESSAGE_DELETED&#x60; メッセージが削除された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;id&#x60;: 削除されたメッセージのId  ### &#x60;MESSAGE_STAMPED&#x60; メッセージにスタンプが押された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;message_id&#x60;: メッセージId + &#x60;user_id&#x60;: スタンプを押したユーザーのId + &#x60;stamp_id&#x60;: スタンプのId + &#x60;count&#x60;: そのユーザーが押した数 + &#x60;created_at&#x60;: そのユーザーがそのスタンプをそのメッセージに最初に押した日時  ### &#x60;MESSAGE_UNSTAMPED&#x60; メッセージからスタンプが外された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;message_id&#x60;: メッセージId + &#x60;user_id&#x60;: スタンプを押したユーザーのId + &#x60;stamp_id&#x60;: スタンプのId  ### &#x60;MESSAGE_PINNED&#x60; メッセージがピン留めされた。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;message_id&#x60;: ピンされたメッセージのID + &#x60;channel_id&#x60;: ピンされたメッセージのチャンネルID  ### &#x60;MESSAGE_UNPINNED&#x60; ピン留めされたメッセージのピンが外された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;message_id&#x60;: ピンが外されたメッセージのID + &#x60;channel_id&#x60;: ピンが外されたメッセージのチャンネルID  ### &#x60;MESSAGE_READ&#x60; 自分があるチャンネルのメッセージを読んだ。  対象: 自分  + &#x60;id&#x60;: 読んだチャンネルId  ### &#x60;STAMP_CREATED&#x60; スタンプが新しく追加された。  対象: 全員  + &#x60;id&#x60;: 作成されたスタンプのId  ### &#x60;STAMP_UPDATED&#x60; スタンプが修正された。  対象: 全員  + &#x60;id&#x60;: 修正されたスタンプのId  ### &#x60;STAMP_DELETED&#x60; スタンプが削除された。  対象: 全員  + &#x60;id&#x60;: 削除されたスタンプのId  ### &#x60;STAMP_PALETTE_CREATED&#x60; スタンプパレットが新しく追加された。  対象: 自分  + &#x60;id&#x60;: 作成されたスタンプパレットのId  ### &#x60;STAMP_PALETTE_UPDATED&#x60; スタンプパレットが修正された。  対象: 自分  + &#x60;id&#x60;: 修正されたスタンプパレットのId  ### &#x60;STAMP_PALETTE_DELETED&#x60; スタンプパレットが削除された。  対象: 自分  + &#x60;id&#x60;: 削除されたスタンプパレットのId  ### &#x60;CLIP_FOLDER_CREATED&#x60; クリップフォルダーが作成された。  対象：自分  + &#x60;id&#x60;: 作成されたクリップフォルダーのId  ### &#x60;CLIP_FOLDER_UPDATED&#x60; クリップフォルダーが修正された。  対象: 自分  + &#x60;id&#x60;: 更新されたクリップフォルダーのId  ### &#x60;CLIP_FOLDER_DELETED&#x60; クリップフォルダーが削除された。  対象: 自分  + &#x60;id&#x60;: 削除されたクリップフォルダーのId  ### &#x60;CLIP_FOLDER_MESSAGE_DELETED&#x60; クリップフォルダーからメッセージが除外された。  対象: 自分  + &#x60;folder_id&#x60;: メッセージが除外されたクリップフォルダーのId + &#x60;message_id&#x60;: クリップフォルダーから除外されたメッセージのId  ### &#x60;CLIP_FOLDER_MESSAGE_ADDED&#x60; クリップフォルダーにメッセージが追加された。  対象: 自分  + &#x60;folder_id&#x60;: メッセージが追加されたクリップフォルダーのId + &#x60;message_id&#x60;: クリップフォルダーに追加されたメッセージのId
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 101 </td><td> Switching Protocols </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> wsWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = wsValidateBeforeCall(null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * WebSocket通知ストリームに接続します (asynchronously)
     * # WebSocketプロトコル ## 送信 &#x60;コマンド:引数1:引数2:...&#x60;のような形式のTextMessageをサーバーに送信することで、このWebSocketセッションに対する設定が実行できる。 ### &#x60;viewstate&#x60;コマンド このWebSocketセッションが見ているチャンネル(イベントを受け取るチャンネル)を設定する。 現時点では1つのセッションに対して1つのチャンネルしか設定できない。  &#x60;viewstate:{チャンネルID}:{閲覧状態}&#x60; + チャンネルID: 対象のチャンネルID + 閲覧状態: &#x60;none&#x60;, &#x60;monitoring&#x60;, &#x60;editing&#x60;  最初の&#x60;viewstate&#x60;コマンドを送る前、または&#x60;viewstate:null&#x60;, &#x60;viewstate:&#x60;を送信した後は、このセッションはどこのチャンネルも見ていないことになる。  ### &#x60;rtcstate&#x60;コマンド 自分のWebRTC状態を変更する。 他のコネクションが既に状態を保持している場合、変更することができません。  &#x60;rtcstate:{チャンネルID}:({状態}:{セッションID})*&#x60;  コネクションが切断された場合、自分のWebRTC状態はリセットされます。  ### &#x60;timeline_streaming&#x60;コマンド 全てのパブリックチャンネルの&#x60;MESSAGE_CREATED&#x60;イベントを受け取るかどうかを設定する。 初期状態は&#x60;off&#x60;です。  &#x60;timeline_streaming:(on|off|true|false)&#x60;  ## 受信 TextMessageとして各種イベントが&#x60;type&#x60;と&#x60;body&#x60;を持つJSONとして非同期に送られます。  例: &#x60;&#x60;&#x60;json {\&quot;type\&quot;:\&quot;USER_ONLINE\&quot;,\&quot;body\&quot;:{\&quot;id\&quot;:\&quot;7dd8e07f-7f5d-4331-9176-b56a4299768b\&quot;}} &#x60;&#x60;&#x60;  ## イベント一覧  ### &#x60;USER_JOINED&#x60; ユーザーが新規登録された。  対象: 全員  + &#x60;id&#x60;: 登録されたユーザーのId  ### &#x60;USER_UPDATED&#x60; ユーザーの情報が更新された。  対象: 全員  + &#x60;id&#x60;: 情報が更新されたユーザーのId  ### &#x60;USER_TAGS_UPDATED&#x60; ユーザーのタグが更新された。  対象: 全員  + &#x60;id&#x60;: タグが更新されたユーザーのId + &#x60;tag_id&#x60;: 更新されたタグのId  ### &#x60;USER_ICON_UPDATED&#x60; ユーザーのアイコンが更新された。  対象: 全員  + &#x60;id&#x60;: アイコンが更新されたユーザーのId  ### &#x60;USER_WEBRTC_STATE_CHANGED&#x60; ユーザーのWebRTCの状態が変化した  対象: 全員  + &#x60;user_id&#x60;: 変更があったユーザーのId + &#x60;channel_id&#x60;: ユーザーの変更後の接続チャンネルのId + &#x60;sessions&#x60;: ユーザーの変更後の状態(配列)   + &#x60;state&#x60;: 状態   + &#x60;sessionId&#x60;: セッションID  ### &#x60;USER_VIEWSTATE_CHANGED&#x60; ユーザーのチャンネルの閲覧状態が変化した  対象: 変化したWSセッションを含めた、該当ユーザーのWSセッション全て  + &#x60;view_states&#x60;: 変化したWSセッションを含めた、該当ユーザーの変更後の状態(配列)   + &#x60;key&#x60;: WSセッションの識別子   + &#x60;channel_id&#x60;: 閲覧しているチャンネルId   + &#x60;state&#x60;: 閲覧状態  ### &#x60;USER_ONLINE&#x60; ユーザーがオンラインになった。  対象: 全員  + &#x60;id&#x60;: オンラインになったユーザーのId  ### &#x60;USER_OFFLINE&#x60; ユーザーがオフラインになった。  対象: 全員  + &#x60;id&#x60;: オフラインになったユーザーのId  ### &#x60;USER_GROUP_CREATED&#x60; ユーザーグループが作成された  対象: 全員  + &#x60;id&#x60;: 作成されたユーザーグループのId  ### &#x60;USER_GROUP_UPDATED&#x60; ユーザーグループが更新された  対象: 全員  + &#x60;id&#x60;: 作成されたユーザーグループのId  ### &#x60;USER_GROUP_DELETED&#x60; ユーザーグループが削除された  対象: 全員  + &#x60;id&#x60;: 削除されたユーザーグループのId  ### &#x60;CHANNEL_CREATED&#x60; チャンネルが新規作成された。  対象: 該当チャンネルを閲覧可能な全員  + &#x60;id&#x60;: 作成されたチャンネルのId + &#x60;dm_user_id&#x60;: (DMの場合のみ) DM相手のユーザーId  ### &#x60;CHANNEL_UPDATED&#x60; チャンネルの情報が変更された。  対象: 該当チャンネルを閲覧可能な全員  + &#x60;id&#x60;: 変更があったチャンネルのId + &#x60;dm_user_id&#x60;: (DMの場合のみ) DM相手のユーザーId  ### &#x60;CHANNEL_DELETED&#x60; チャンネルが削除された。  対象: 該当チャンネルを閲覧可能な全員  + &#x60;id&#x60;: 削除されたチャンネルのId + &#x60;dm_user_id&#x60;: (DMの場合のみ) DM相手のユーザーId  ### &#x60;CHANNEL_STARED&#x60; 自分がチャンネルをスターした。  対象: 自分  + &#x60;id&#x60;: スターしたチャンネルのId  ### &#x60;CHANNEL_UNSTARED&#x60; 自分がチャンネルのスターを解除した。  対象: 自分  + &#x60;id&#x60;: スターしたチャンネルのId  ### &#x60;CHANNEL_VIEWERS_CHANGED&#x60; チャンネルの閲覧者が変化した。  対象: 該当チャンネルを閲覧しているユーザー  + &#x60;id&#x60;: 変化したチャンネルのId + &#x60;viewers&#x60;: 変化後の閲覧者(配列)   + &#x60;userId&#x60;: ユーザーId   + &#x60;state&#x60;: 閲覧状態   + &#x60;updatedAt&#x60;: 閲覧状態の更新日時  ### &#x60;CHANNEL_SUBSCRIBERS_CHANGED&#x60; チャンネルの購読者が変化した。  対象: 該当チャンネルを閲覧しているユーザー  + &#x60;id&#x60;: 変化したチャンネルのId  ### &#x60;MESSAGE_CREATED&#x60; メッセージが投稿された。  対象: 投稿チャンネルを閲覧しているユーザー・投稿チャンネルに通知をつけているユーザー・メンションを受けたユーザー  + &#x60;id&#x60;: 投稿されたメッセージのId + &#x60;is_citing&#x60;: 投稿されたメッセージがWebSocketを接続しているユーザーの投稿を引用しているかどうか  ### &#x60;MESSAGE_UPDATED&#x60; メッセージが更新された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;id&#x60;: 更新されたメッセージのId  ### &#x60;MESSAGE_DELETED&#x60; メッセージが削除された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;id&#x60;: 削除されたメッセージのId  ### &#x60;MESSAGE_STAMPED&#x60; メッセージにスタンプが押された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;message_id&#x60;: メッセージId + &#x60;user_id&#x60;: スタンプを押したユーザーのId + &#x60;stamp_id&#x60;: スタンプのId + &#x60;count&#x60;: そのユーザーが押した数 + &#x60;created_at&#x60;: そのユーザーがそのスタンプをそのメッセージに最初に押した日時  ### &#x60;MESSAGE_UNSTAMPED&#x60; メッセージからスタンプが外された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;message_id&#x60;: メッセージId + &#x60;user_id&#x60;: スタンプを押したユーザーのId + &#x60;stamp_id&#x60;: スタンプのId  ### &#x60;MESSAGE_PINNED&#x60; メッセージがピン留めされた。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;message_id&#x60;: ピンされたメッセージのID + &#x60;channel_id&#x60;: ピンされたメッセージのチャンネルID  ### &#x60;MESSAGE_UNPINNED&#x60; ピン留めされたメッセージのピンが外された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;message_id&#x60;: ピンが外されたメッセージのID + &#x60;channel_id&#x60;: ピンが外されたメッセージのチャンネルID  ### &#x60;MESSAGE_READ&#x60; 自分があるチャンネルのメッセージを読んだ。  対象: 自分  + &#x60;id&#x60;: 読んだチャンネルId  ### &#x60;STAMP_CREATED&#x60; スタンプが新しく追加された。  対象: 全員  + &#x60;id&#x60;: 作成されたスタンプのId  ### &#x60;STAMP_UPDATED&#x60; スタンプが修正された。  対象: 全員  + &#x60;id&#x60;: 修正されたスタンプのId  ### &#x60;STAMP_DELETED&#x60; スタンプが削除された。  対象: 全員  + &#x60;id&#x60;: 削除されたスタンプのId  ### &#x60;STAMP_PALETTE_CREATED&#x60; スタンプパレットが新しく追加された。  対象: 自分  + &#x60;id&#x60;: 作成されたスタンプパレットのId  ### &#x60;STAMP_PALETTE_UPDATED&#x60; スタンプパレットが修正された。  対象: 自分  + &#x60;id&#x60;: 修正されたスタンプパレットのId  ### &#x60;STAMP_PALETTE_DELETED&#x60; スタンプパレットが削除された。  対象: 自分  + &#x60;id&#x60;: 削除されたスタンプパレットのId  ### &#x60;CLIP_FOLDER_CREATED&#x60; クリップフォルダーが作成された。  対象：自分  + &#x60;id&#x60;: 作成されたクリップフォルダーのId  ### &#x60;CLIP_FOLDER_UPDATED&#x60; クリップフォルダーが修正された。  対象: 自分  + &#x60;id&#x60;: 更新されたクリップフォルダーのId  ### &#x60;CLIP_FOLDER_DELETED&#x60; クリップフォルダーが削除された。  対象: 自分  + &#x60;id&#x60;: 削除されたクリップフォルダーのId  ### &#x60;CLIP_FOLDER_MESSAGE_DELETED&#x60; クリップフォルダーからメッセージが除外された。  対象: 自分  + &#x60;folder_id&#x60;: メッセージが除外されたクリップフォルダーのId + &#x60;message_id&#x60;: クリップフォルダーから除外されたメッセージのId  ### &#x60;CLIP_FOLDER_MESSAGE_ADDED&#x60; クリップフォルダーにメッセージが追加された。  対象: 自分  + &#x60;folder_id&#x60;: メッセージが追加されたクリップフォルダーのId + &#x60;message_id&#x60;: クリップフォルダーに追加されたメッセージのId
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 101 </td><td> Switching Protocols </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call wsAsync(final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = wsValidateBeforeCall(_callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
}
